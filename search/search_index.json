{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Below is a comprehensive solution to the projectile motion problem, structured as a Markdown document with embedded Python code for simulations, theoretical derivations, and visualizations. The response addresses all deliverables while keeping explanations concise yet detailed. Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Derivation of Governing Equations Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch velocity. We assume a 2D plane, neglecting air resistance for simplicity. The fundamental equations arise from Newton\u2019s second law, where the only force is gravity acting downward. The acceleration is: x-direction : \\(a_x = 0\\) y-direction : \\(a_y = -g\\) , where \\(g = 9.81 \\, \\text{m/s}^2\\) . Integrating acceleration with respect to time: Velocity : \\(v_x(t) = v_0 \\cos \\theta\\) \\(v_y(t) = v_0 \\sin \\theta - g t\\) Position : \\(x(t) = (v_0 \\cos \\theta) t\\) \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2\\) Here, \\(v_0\\) is the initial velocity, and \\(\\theta\\) is the angle of projection relative to the horizontal. These equations assume launch from the origin ( \\(x_0 = 0, y_0 = 0\\) ). Family of Solutions The equations form a parametric family of solutions, with free parameters: - Initial velocity ( \\(v_0\\) ): Scales the trajectory size. - Angle of projection ( \\(\\theta\\) ): Determines the shape of the parabolic path. - Gravitational acceleration ( \\(g\\) ): Affects the vertical motion and scales the trajectory. Varying these parameters generates different trajectories, from flat, short paths (low \\(\\theta\\) , small \\(v_0\\) ) to high, long arcs (near \\(\\theta = 45^\\circ\\) , large \\(v_0\\) ). Range Derivation The range is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : \\((v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = 0\\) Factor out \\(t\\) : \\(t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0\\) Solutions are \\(t = 0\\) (launch) and: \\(t = \\frac{2 v_0 \\sin \\theta}{g}\\) Substitute into \\(x(t)\\) : \\(R = x\\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) = (v_0 \\cos \\theta) \\cdot \\frac{2 v_0 \\sin \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g}\\) Using the identity \\(\\sin 2\\theta = 2 \\sin \\theta \\cos \\theta\\) : \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) This shows the range depends on \\(\\theta\\) , \\(v_0\\) , and \\(g\\) . 2. Analysis of the Range Dependence on Angle of Projection The term \\(\\sin 2\\theta\\) governs the angular dependence. Since \\(\\sin 2\\theta\\) peaks at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) , the maximum range occurs at: \\(R_{\\text{max}} = \\frac{v_0^2}{g} \\quad (\\text{when } \\sin 2\\theta = 1)\\) For \\(\\theta < 45^\\circ\\) or \\(\\theta > 45^\\circ\\) , the range decreases symmetrically, as \\(\\sin 2(90^\\circ - \\theta) = \\sin 2\\theta\\) . Thus, angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges. Influence of Other Parameters Initial Velocity ( \\(v_0\\) ) : The range scales with \\(v_0^2\\) , so doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ) : The range is inversely proportional to \\(g\\) . On a planet with lower \\(g\\) , the range increases. Launch Height : If \\(y_0 \\neq 0\\) , the time to reach \\(y = 0\\) changes, modifying the range (addressed later). 3. Practical Applications The idealized model applies to: - Sports : Trajectories of soccer balls, golf balls, or javelins, where launch angle optimization is key. - Engineering : Artillery or rocket launches, requiring precise range calculations. - Astrophysics : Simplified models of orbital insertion or low-altitude satellite paths. Extensions to Real-World Scenarios Uneven Terrain : If the landing height differs from the launch height, solve \\(y(t) = y_{\\text{land}}\\) . For a height difference \\(h\\) : \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = h\\) This yields a quadratic equation for \\(t\\) , and the range becomes: \\(R = (v_0 \\cos \\theta) t_{\\text{land}}\\) Air Resistance : Introduce a drag force proportional to velocity or its square, modifying the differential equations to: \\(m \\ddot{x} = -k \\dot{x}, \\quad m \\ddot{y} = -m g - k \\dot{y}\\) These require numerical solutions, as analytical forms are complex. 4. Implementation Below is a Python script to simulate projectile motion and visualize the range as a function of \\(\\theta\\) . import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.arange(0, 91, 1) # Angles from 0 to 90 degrees theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta_rad, g=9.81): return (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs angle for different v0 plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_projectile(v0, theta_rad) plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Simulate a single trajectory (example: v0 = 20 m/s, theta = 45 deg) v0 = 20 theta = np.deg2rad(45) t_flight = (2 * v0 * np.sin(theta)) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.figure(figsize=(10, 6)) plt.plot(x, y) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Projectile Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.grid(True) plt.show() Output Description Range Plot : Shows range vs. angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . Each curve peaks at \\(\\theta = 45^\\circ\\) , with higher \\(v_0\\) yielding larger ranges. Trajectory Plot : Displays the parabolic path for \\(v_0 = 20 \\, \\text{m/s}\\) , \\(\\theta = 45^\\circ\\) , confirming the theoretical range. Limitations and Extensions Limitations Idealized Model : Assumes no air resistance, constant gravity, and flat terrain. Launch Height : Ignores \\(y_0 \\neq 0\\) , which affects real-world scenarios like cliff launches. Drag and Wind : Neglects aerodynamic forces, critical for lightweight or fast projectiles. Suggestions for Realism Air Resistance : Solve the modified differential equations numerically using tools like scipy.integrate.odeint . Wind : Add a velocity-dependent force term to model crosswinds. Variable Terrain : Incorporate a height function \\(y_{\\text{land}}(x)\\) and solve for intersection points. Spin Effects : For sports applications, include Magnus forces for spinning objects. Conclusion This analysis reveals the elegance of projectile motion, with the range\u2019s dependence on \\(\\sin 2\\theta\\) highlighting the optimal \\(45^\\circ\\) angle. Variations in \\(v_0\\) and \\(g\\) scale the system, while extensions like drag or terrain require numerical tools. The model\u2019s simplicity belies its power to describe diverse phenomena, from sports to space exploration. This response includes: - A detailed derivation of the equations and range formula. - Analysis of parameter effects. - Python code for simulations and visualizations. - Discussion of real-world applications and model limitations. Let me know if you\u2019d like further refinements or additional scenarios (e.g., air resistance simulation)!","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations","text":"Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch velocity. We assume a 2D plane, neglecting air resistance for simplicity. The fundamental equations arise from Newton\u2019s second law, where the only force is gravity acting downward. The acceleration is: x-direction : \\(a_x = 0\\) y-direction : \\(a_y = -g\\) , where \\(g = 9.81 \\, \\text{m/s}^2\\) . Integrating acceleration with respect to time: Velocity : \\(v_x(t) = v_0 \\cos \\theta\\) \\(v_y(t) = v_0 \\sin \\theta - g t\\) Position : \\(x(t) = (v_0 \\cos \\theta) t\\) \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2\\) Here, \\(v_0\\) is the initial velocity, and \\(\\theta\\) is the angle of projection relative to the horizontal. These equations assume launch from the origin ( \\(x_0 = 0, y_0 = 0\\) ).","title":"Derivation of Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The equations form a parametric family of solutions, with free parameters: - Initial velocity ( \\(v_0\\) ): Scales the trajectory size. - Angle of projection ( \\(\\theta\\) ): Determines the shape of the parabolic path. - Gravitational acceleration ( \\(g\\) ): Affects the vertical motion and scales the trajectory. Varying these parameters generates different trajectories, from flat, short paths (low \\(\\theta\\) , small \\(v_0\\) ) to high, long arcs (near \\(\\theta = 45^\\circ\\) , large \\(v_0\\) ).","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-derivation","text":"The range is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : \\((v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = 0\\) Factor out \\(t\\) : \\(t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0\\) Solutions are \\(t = 0\\) (launch) and: \\(t = \\frac{2 v_0 \\sin \\theta}{g}\\) Substitute into \\(x(t)\\) : \\(R = x\\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) = (v_0 \\cos \\theta) \\cdot \\frac{2 v_0 \\sin \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g}\\) Using the identity \\(\\sin 2\\theta = 2 \\sin \\theta \\cos \\theta\\) : \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) This shows the range depends on \\(\\theta\\) , \\(v_0\\) , and \\(g\\) .","title":"Range Derivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle-of-projection","text":"The term \\(\\sin 2\\theta\\) governs the angular dependence. Since \\(\\sin 2\\theta\\) peaks at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) , the maximum range occurs at: \\(R_{\\text{max}} = \\frac{v_0^2}{g} \\quad (\\text{when } \\sin 2\\theta = 1)\\) For \\(\\theta < 45^\\circ\\) or \\(\\theta > 45^\\circ\\) , the range decreases symmetrically, as \\(\\sin 2(90^\\circ - \\theta) = \\sin 2\\theta\\) . Thus, angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges.","title":"Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-other-parameters","text":"Initial Velocity ( \\(v_0\\) ) : The range scales with \\(v_0^2\\) , so doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ) : The range is inversely proportional to \\(g\\) . On a planet with lower \\(g\\) , the range increases. Launch Height : If \\(y_0 \\neq 0\\) , the time to reach \\(y = 0\\) changes, modifying the range (addressed later).","title":"Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"The idealized model applies to: - Sports : Trajectories of soccer balls, golf balls, or javelins, where launch angle optimization is key. - Engineering : Artillery or rocket launches, requiring precise range calculations. - Astrophysics : Simplified models of orbital insertion or low-altitude satellite paths.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions-to-real-world-scenarios","text":"Uneven Terrain : If the landing height differs from the launch height, solve \\(y(t) = y_{\\text{land}}\\) . For a height difference \\(h\\) : \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = h\\) This yields a quadratic equation for \\(t\\) , and the range becomes: \\(R = (v_0 \\cos \\theta) t_{\\text{land}}\\) Air Resistance : Introduce a drag force proportional to velocity or its square, modifying the differential equations to: \\(m \\ddot{x} = -k \\dot{x}, \\quad m \\ddot{y} = -m g - k \\dot{y}\\) These require numerical solutions, as analytical forms are complex.","title":"Extensions to Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate projectile motion and visualize the range as a function of \\(\\theta\\) . import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.arange(0, 91, 1) # Angles from 0 to 90 degrees theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta_rad, g=9.81): return (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs angle for different v0 plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_projectile(v0, theta_rad) plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Simulate a single trajectory (example: v0 = 20 m/s, theta = 45 deg) v0 = 20 theta = np.deg2rad(45) t_flight = (2 * v0 * np.sin(theta)) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.figure(figsize=(10, 6)) plt.plot(x, y) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Projectile Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output-description","text":"Range Plot : Shows range vs. angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . Each curve peaks at \\(\\theta = 45^\\circ\\) , with higher \\(v_0\\) yielding larger ranges. Trajectory Plot : Displays the parabolic path for \\(v_0 = 20 \\, \\text{m/s}\\) , \\(\\theta = 45^\\circ\\) , confirming the theoretical range.","title":"Output Description"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Idealized Model : Assumes no air resistance, constant gravity, and flat terrain. Launch Height : Ignores \\(y_0 \\neq 0\\) , which affects real-world scenarios like cliff launches. Drag and Wind : Neglects aerodynamic forces, critical for lightweight or fast projectiles.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#suggestions-for-realism","text":"Air Resistance : Solve the modified differential equations numerically using tools like scipy.integrate.odeint . Wind : Add a velocity-dependent force term to model crosswinds. Variable Terrain : Incorporate a height function \\(y_{\\text{land}}(x)\\) and solve for intersection points. Spin Effects : For sports applications, include Magnus forces for spinning objects.","title":"Suggestions for Realism"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis reveals the elegance of projectile motion, with the range\u2019s dependence on \\(\\sin 2\\theta\\) highlighting the optimal \\(45^\\circ\\) angle. Variations in \\(v_0\\) and \\(g\\) scale the system, while extensions like drag or terrain require numerical tools. The model\u2019s simplicity belies its power to describe diverse phenomena, from sports to space exploration. This response includes: - A detailed derivation of the equations and range formula. - Analysis of parameter effects. - Python code for simulations and visualizations. - Discussion of real-world applications and model limitations. Let me know if you\u2019d like further refinements or additional scenarios (e.g., air resistance simulation)!","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] where: \\(\\theta(t)\\) : Angular displacement (rad) \\(\\beta\\) : Damping coefficient (s\u207b\u00b9) \\(\\omega_0 = \\sqrt{g/l}\\) : Natural frequency (rad/s), \\(g = 9.81 , \\text{m/s}^2\\) , \\(l\\) : pendulum length (m) \\(A\\) : Driving amplitude (rad/s\u00b2) \\(\\omega\\) : Driving frequency (rad/s) \\(t\\) : Time (s) Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin(\\theta) \\approx \\theta\\) , simplifying to: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This linear ODE has a solution combining homogeneous ( \\(\\theta_h\\) ) and particular ( \\(\\theta_p\\) ) parts: Homogeneous solution (underdamped, \\(\\beta < \\omega_0\\) ): \\[ \\theta_h(t) = e^{-\\beta t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right), \\quad \\omega_d = \\sqrt{\\omega_0^2 - \\beta^2} \\] Particular solution: Assume \\(\\theta_p(t) = D_1 \\cos(\\omega t) + D_2 \\sin(\\omega t)\\) . Solving: \\[ D_1 = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}, \\quad D_2 = \\frac{2A\\beta\\omega}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2} \\] Steady-state amplitude: \\[ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}} \\] Resonance Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(D\\) . Damping ( \\(\\beta > 0\\) ) prevents infinite amplitude, shifting the peak slightly. This amplifies energy transfer, increasing oscillation amplitude. 2. Analysis of Dynamics Parameter Effects Damping ( \\(\\beta\\) ): High \\(\\beta\\) suppresses amplitude and chaos; low \\(\\beta\\) allows complex dynamics. Driving amplitude ( \\(A\\) ): Large \\(A\\) induces nonlinearity, potentially chaotic motion. Driving frequency ( \\(\\omega\\) ): Near \\(\\omega_0\\) , resonance; far from \\(\\omega_0\\) , quasiperiodic or chaotic motion. Transition to Chaos The nonlinear \\(\\sin(\\theta)\\) term drives transitions from periodic (synchronized with driving) to chaotic motion (sensitive to initial conditions). Phase portraits show loops (periodic) or tangled paths (chaotic). Poincar\u00e9 sections display few points (periodic) or scattered clouds (chaotic). 3. Practical Applications Energy harvesting: Oscillatory motion in piezoelectric devices generates electricity. Structural engineering: Models vibrations in bridges under periodic forces. Electronics: Driven RLC circuits, analogous to the pendulum, used in signal processing. Biomechanics: Describes gait or robotic motion under periodic forcing. 4. Implementation The Python script below simulates the pendulum using Runge-Kutta, visualizing time series, phase portraits, Poincar\u00e9 sections, resonance curve, and bifurcation diagram. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # m/s^2 l = 1.0 # pendulum length (m) omega0 = np.sqrt(g / l) # natural frequency beta_values = [0.05, 0.1, 0.5] # damping coefficients A = 1.5 # driving amplitude omega = 2.0 # driving frequency t_span = (0, 100) # time span dt = 0.01 # time step t_eval = np.arange(0, 100, dt) theta0, omega0_init = 0.1, 0.0 # initial conditions # Differential equation def pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -2 * beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Simulate for different beta values plt.figure(figsize=(10, 6)) for beta in beta_values: sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta, omega0, A, omega)) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {beta}') plt.xlabel('Time (s)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Time Series for Different Damping Coefficients') plt.legend() plt.grid(True) plt.savefig('time_series.png') plt.show() # Phase portrait (example: beta = 0.1) sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta_values[1], omega0, A, omega)) theta, omega_dot = sol.y[0], sol.y[1] plt.figure(figsize=(8, 6)) plt.plot(theta, omega_dot) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait (\u03b2 = 0.1)') plt.grid(True) plt.savefig('phase_portrait.png') plt.show() # Poincar\u00e9 section T = 2 * np.pi / omega poincare_times = np.arange(0, sol.t[-1], T) poincare_indices = np.searchsorted(sol.t, poincare_times) theta_poincare = theta[poincare_indices] omega_poincare = omega_dot[poincare_indices] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section (\u03b2 = 0.1)') plt.grid(True) plt.savefig('poincare_section.png') plt.show() # Resonance curve omega_range = np.linspace(0.5, 3.0, 100) amplitude = A / np.sqrt((omega0**2 - omega_range**2)**2 + (2 * beta_values[1] * omega_range)**2) plt.figure(figsize=(10, 6)) plt.plot(omega_range, amplitude) plt.axvline(omega0, color='r', linestyle='--', label=r'$\\omega_0$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel('Amplitude (rad)') plt.title('Resonance Curve (\u03b2 = 0.1)') plt.legend() plt.grid(True) plt.savefig('resonance_curve.png') plt.show() # Bifurcation diagram A_range = np.linspace(0.5, 2.5, 100) theta_bifurcation = [] t_span_bif = (0, 200) t_eval_bif = np.arange(100, 200, dt) for A in A_range: sol_bif = solve_ivp(pendulum, t_span_bif, [theta0, omega0_init], method='RK45', t_eval=t_eval_bif, args=(beta_values[1], omega0, A, omega)) theta_bif = sol_bif.y[0] poincare_indices_bif = np.searchsorted(sol_bif.t, np.arange(100, 200, T)) theta_bifurcation.extend(theta_bif[poincare_indices_bif]) A_bifurcation = np.repeat(A_range, len(poincare_indices_bif)) plt.figure(figsize=(10, 6)) plt.scatter(A_bifurcation, theta_bifurcation, s=1, alpha=0.5) plt.xlabel('Driving Amplitude $A$ (rad/s\u00b2)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Bifurcation Diagram (\u03b2 = 0.1)') plt.grid(True) plt.savefig('bifurcation_diagram.png') plt.show() Output Description Time Series: Shows \\(\\theta(t)\\) for \\(\\beta = 0.05, 0.1, 0.5\\) , illustrating damping effects. Phase Portrait: Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for \\(\\beta = 0.1\\) , showing trajectory behavior. Poincar\u00e9 Section: Displays states at driving periods for \\(\\beta = 0.1\\) , indicating periodic or chaotic motion. Resonance Curve: Plots amplitude vs. \\(\\omega\\) for \\(\\beta = 0.1\\) , peaking near \\(\\omega_0\\) . Bifurcation Diagram: Shows \\(\\theta\\) at Poincar\u00e9 times vs. \\(A\\) , revealing transitions to chaos. Limitations and Extensions Limitations Small-angle approximation fails for large \\(\\theta\\) . Linear damping oversimplifies real friction. Assumes periodic forcing, limiting real-world applicability. Extensions Model nonlinear damping (e.g., \\(|\\dot{\\theta}|\\dot{\\theta}\\) ). Include non-periodic or random forcing. Simulate coupled pendulums for complex interactions. Conclusion The forced damped pendulum, governed by \\(\\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t)\\) , exhibits rich dynamics from resonance to chaos. Simulations reveal parameter effects, with visualizations highlighting transitions. Applications span engineering and physics, and extensions could enhance realism.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Governing Equation The motion of a forced damped pendulum is governed by: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] where: \\(\\theta(t)\\) : Angular displacement (rad) \\(\\beta\\) : Damping coefficient (s\u207b\u00b9) \\(\\omega_0 = \\sqrt{g/l}\\) : Natural frequency (rad/s), \\(g = 9.81 , \\text{m/s}^2\\) , \\(l\\) : pendulum length (m) \\(A\\) : Driving amplitude (rad/s\u00b2) \\(\\omega\\) : Driving frequency (rad/s) \\(t\\) : Time (s) Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin(\\theta) \\approx \\theta\\) , simplifying to: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This linear ODE has a solution combining homogeneous ( \\(\\theta_h\\) ) and particular ( \\(\\theta_p\\) ) parts: Homogeneous solution (underdamped, \\(\\beta < \\omega_0\\) ): \\[ \\theta_h(t) = e^{-\\beta t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right), \\quad \\omega_d = \\sqrt{\\omega_0^2 - \\beta^2} \\] Particular solution: Assume \\(\\theta_p(t) = D_1 \\cos(\\omega t) + D_2 \\sin(\\omega t)\\) . Solving: \\[ D_1 = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}, \\quad D_2 = \\frac{2A\\beta\\omega}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2} \\] Steady-state amplitude: \\[ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}} \\] Resonance Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(D\\) . Damping ( \\(\\beta > 0\\) ) prevents infinite amplitude, shifting the peak slightly. This amplifies energy transfer, increasing oscillation amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Parameter Effects Damping ( \\(\\beta\\) ): High \\(\\beta\\) suppresses amplitude and chaos; low \\(\\beta\\) allows complex dynamics. Driving amplitude ( \\(A\\) ): Large \\(A\\) induces nonlinearity, potentially chaotic motion. Driving frequency ( \\(\\omega\\) ): Near \\(\\omega_0\\) , resonance; far from \\(\\omega_0\\) , quasiperiodic or chaotic motion. Transition to Chaos The nonlinear \\(\\sin(\\theta)\\) term drives transitions from periodic (synchronized with driving) to chaotic motion (sensitive to initial conditions). Phase portraits show loops (periodic) or tangled paths (chaotic). Poincar\u00e9 sections display few points (periodic) or scattered clouds (chaotic).","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting: Oscillatory motion in piezoelectric devices generates electricity. Structural engineering: Models vibrations in bridges under periodic forces. Electronics: Driven RLC circuits, analogous to the pendulum, used in signal processing. Biomechanics: Describes gait or robotic motion under periodic forcing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"The Python script below simulates the pendulum using Runge-Kutta, visualizing time series, phase portraits, Poincar\u00e9 sections, resonance curve, and bifurcation diagram. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # m/s^2 l = 1.0 # pendulum length (m) omega0 = np.sqrt(g / l) # natural frequency beta_values = [0.05, 0.1, 0.5] # damping coefficients A = 1.5 # driving amplitude omega = 2.0 # driving frequency t_span = (0, 100) # time span dt = 0.01 # time step t_eval = np.arange(0, 100, dt) theta0, omega0_init = 0.1, 0.0 # initial conditions # Differential equation def pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -2 * beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Simulate for different beta values plt.figure(figsize=(10, 6)) for beta in beta_values: sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta, omega0, A, omega)) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {beta}') plt.xlabel('Time (s)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Time Series for Different Damping Coefficients') plt.legend() plt.grid(True) plt.savefig('time_series.png') plt.show() # Phase portrait (example: beta = 0.1) sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta_values[1], omega0, A, omega)) theta, omega_dot = sol.y[0], sol.y[1] plt.figure(figsize=(8, 6)) plt.plot(theta, omega_dot) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait (\u03b2 = 0.1)') plt.grid(True) plt.savefig('phase_portrait.png') plt.show() # Poincar\u00e9 section T = 2 * np.pi / omega poincare_times = np.arange(0, sol.t[-1], T) poincare_indices = np.searchsorted(sol.t, poincare_times) theta_poincare = theta[poincare_indices] omega_poincare = omega_dot[poincare_indices] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section (\u03b2 = 0.1)') plt.grid(True) plt.savefig('poincare_section.png') plt.show() # Resonance curve omega_range = np.linspace(0.5, 3.0, 100) amplitude = A / np.sqrt((omega0**2 - omega_range**2)**2 + (2 * beta_values[1] * omega_range)**2) plt.figure(figsize=(10, 6)) plt.plot(omega_range, amplitude) plt.axvline(omega0, color='r', linestyle='--', label=r'$\\omega_0$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel('Amplitude (rad)') plt.title('Resonance Curve (\u03b2 = 0.1)') plt.legend() plt.grid(True) plt.savefig('resonance_curve.png') plt.show() # Bifurcation diagram A_range = np.linspace(0.5, 2.5, 100) theta_bifurcation = [] t_span_bif = (0, 200) t_eval_bif = np.arange(100, 200, dt) for A in A_range: sol_bif = solve_ivp(pendulum, t_span_bif, [theta0, omega0_init], method='RK45', t_eval=t_eval_bif, args=(beta_values[1], omega0, A, omega)) theta_bif = sol_bif.y[0] poincare_indices_bif = np.searchsorted(sol_bif.t, np.arange(100, 200, T)) theta_bifurcation.extend(theta_bif[poincare_indices_bif]) A_bifurcation = np.repeat(A_range, len(poincare_indices_bif)) plt.figure(figsize=(10, 6)) plt.scatter(A_bifurcation, theta_bifurcation, s=1, alpha=0.5) plt.xlabel('Driving Amplitude $A$ (rad/s\u00b2)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Bifurcation Diagram (\u03b2 = 0.1)') plt.grid(True) plt.savefig('bifurcation_diagram.png') plt.show() Output Description Time Series: Shows \\(\\theta(t)\\) for \\(\\beta = 0.05, 0.1, 0.5\\) , illustrating damping effects. Phase Portrait: Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for \\(\\beta = 0.1\\) , showing trajectory behavior. Poincar\u00e9 Section: Displays states at driving periods for \\(\\beta = 0.1\\) , indicating periodic or chaotic motion. Resonance Curve: Plots amplitude vs. \\(\\omega\\) for \\(\\beta = 0.1\\) , peaking near \\(\\omega_0\\) . Bifurcation Diagram: Shows \\(\\theta\\) at Poincar\u00e9 times vs. \\(A\\) , revealing transitions to chaos. Limitations and Extensions Limitations Small-angle approximation fails for large \\(\\theta\\) . Linear damping oversimplifies real friction. Assumes periodic forcing, limiting real-world applicability. Extensions Model nonlinear damping (e.g., \\(|\\dot{\\theta}|\\dot{\\theta}\\) ). Include non-periodic or random forcing. Simulate coupled pendulums for complex interactions. Conclusion The forced damped pendulum, governed by \\(\\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t)\\) , exhibits rich dynamics from resonance to chaos. Simulations reveal parameter effects, with visualizations highlighting transitions. Applications span engineering and physics, and extensions could enhance realism.","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}