{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Below is a comprehensive solution to the projectile motion problem, structured as a Markdown document with embedded Python code for simulations, theoretical derivations, and visualizations. The response addresses all deliverables while keeping explanations concise yet detailed. Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Derivation of Governing Equations Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch velocity. We assume a 2D plane, neglecting air resistance for simplicity. The fundamental equations arise from Newton\u2019s second law, where the only force is gravity acting downward. The acceleration is: x-direction : \\(a_x = 0\\) y-direction : \\(a_y = -g\\) , where \\(g = 9.81 \\, \\text{m/s}^2\\) . Integrating acceleration with respect to time: Velocity : \\(v_x(t) = v_0 \\cos \\theta\\) \\(v_y(t) = v_0 \\sin \\theta - g t\\) Position : \\(x(t) = (v_0 \\cos \\theta) t\\) \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2\\) Here, \\(v_0\\) is the initial velocity, and \\(\\theta\\) is the angle of projection relative to the horizontal. These equations assume launch from the origin ( \\(x_0 = 0, y_0 = 0\\) ). Family of Solutions The equations form a parametric family of solutions, with free parameters: - Initial velocity ( \\(v_0\\) ): Scales the trajectory size. - Angle of projection ( \\(\\theta\\) ): Determines the shape of the parabolic path. - Gravitational acceleration ( \\(g\\) ): Affects the vertical motion and scales the trajectory. Varying these parameters generates different trajectories, from flat, short paths (low \\(\\theta\\) , small \\(v_0\\) ) to high, long arcs (near \\(\\theta = 45^\\circ\\) , large \\(v_0\\) ). Range Derivation The range is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : \\((v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = 0\\) Factor out \\(t\\) : \\(t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0\\) Solutions are \\(t = 0\\) (launch) and: \\(t = \\frac{2 v_0 \\sin \\theta}{g}\\) Substitute into \\(x(t)\\) : \\(R = x\\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) = (v_0 \\cos \\theta) \\cdot \\frac{2 v_0 \\sin \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g}\\) Using the identity \\(\\sin 2\\theta = 2 \\sin \\theta \\cos \\theta\\) : \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) This shows the range depends on \\(\\theta\\) , \\(v_0\\) , and \\(g\\) . 2. Analysis of the Range Dependence on Angle of Projection The term \\(\\sin 2\\theta\\) governs the angular dependence. Since \\(\\sin 2\\theta\\) peaks at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) , the maximum range occurs at: \\(R_{\\text{max}} = \\frac{v_0^2}{g} \\quad (\\text{when } \\sin 2\\theta = 1)\\) For \\(\\theta < 45^\\circ\\) or \\(\\theta > 45^\\circ\\) , the range decreases symmetrically, as \\(\\sin 2(90^\\circ - \\theta) = \\sin 2\\theta\\) . Thus, angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges. Influence of Other Parameters Initial Velocity ( \\(v_0\\) ) : The range scales with \\(v_0^2\\) , so doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ) : The range is inversely proportional to \\(g\\) . On a planet with lower \\(g\\) , the range increases. Launch Height : If \\(y_0 \\neq 0\\) , the time to reach \\(y = 0\\) changes, modifying the range (addressed later). 3. Practical Applications The idealized model applies to: - Sports : Trajectories of soccer balls, golf balls, or javelins, where launch angle optimization is key. - Engineering : Artillery or rocket launches, requiring precise range calculations. - Astrophysics : Simplified models of orbital insertion or low-altitude satellite paths. Extensions to Real-World Scenarios Uneven Terrain : If the landing height differs from the launch height, solve \\(y(t) = y_{\\text{land}}\\) . For a height difference \\(h\\) : \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = h\\) This yields a quadratic equation for \\(t\\) , and the range becomes: \\(R = (v_0 \\cos \\theta) t_{\\text{land}}\\) Air Resistance : Introduce a drag force proportional to velocity or its square, modifying the differential equations to: \\(m \\ddot{x} = -k \\dot{x}, \\quad m \\ddot{y} = -m g - k \\dot{y}\\) These require numerical solutions, as analytical forms are complex. 4. Implementation Below is a Python script to simulate projectile motion and visualize the range as a function of \\(\\theta\\) . import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.arange(0, 91, 1) # Angles from 0 to 90 degrees theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta_rad, g=9.81): return (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs angle for different v0 plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_projectile(v0, theta_rad) plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Simulate a single trajectory (example: v0 = 20 m/s, theta = 45 deg) v0 = 20 theta = np.deg2rad(45) t_flight = (2 * v0 * np.sin(theta)) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.figure(figsize=(10, 6)) plt.plot(x, y) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Projectile Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.grid(True) plt.show() Output Description Range Plot : Shows range vs. angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . Each curve peaks at \\(\\theta = 45^\\circ\\) , with higher \\(v_0\\) yielding larger ranges. Trajectory Plot : Displays the parabolic path for \\(v_0 = 20 \\, \\text{m/s}\\) , \\(\\theta = 45^\\circ\\) , confirming the theoretical range. Limitations and Extensions Limitations Idealized Model : Assumes no air resistance, constant gravity, and flat terrain. Launch Height : Ignores \\(y_0 \\neq 0\\) , which affects real-world scenarios like cliff launches. Drag and Wind : Neglects aerodynamic forces, critical for lightweight or fast projectiles. Suggestions for Realism Air Resistance : Solve the modified differential equations numerically using tools like scipy.integrate.odeint . Wind : Add a velocity-dependent force term to model crosswinds. Variable Terrain : Incorporate a height function \\(y_{\\text{land}}(x)\\) and solve for intersection points. Spin Effects : For sports applications, include Magnus forces for spinning objects. Conclusion This analysis reveals the elegance of projectile motion, with the range\u2019s dependence on \\(\\sin 2\\theta\\) highlighting the optimal \\(45^\\circ\\) angle. Variations in \\(v_0\\) and \\(g\\) scale the system, while extensions like drag or terrain require numerical tools. The model\u2019s simplicity belies its power to describe diverse phenomena, from sports to space exploration. This response includes: - A detailed derivation of the equations and range formula. - Analysis of parameter effects. - Python code for simulations and visualizations. - Discussion of real-world applications and model limitations. Let me know if you\u2019d like further refinements or additional scenarios (e.g., air resistance simulation)! import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 # initial velocity in m/s angles = [15, 45, 75] # launch angles in degrees g = 9.81 # acceleration due to gravity in m/s^2 # Create the plot plt.figure(figsize=(10, 6)) for angle in angles: theta = np.radians(angle) # convert degrees to radians t_flight = 2 * v0 * np.sin(theta) / g # total time of flight t = np.linspace(0, t_flight, num=500) # time points x = v0 * np.cos(theta) * t # horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # vertical position plt.plot(x, y, label=f'{angle}\u00b0') # Customize the plot plt.title('Projectile Motion at 50 m/s with Different Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.show() P\u0131cture Code import numpy as np import matplotlib.pyplot as plt # Constants speeds = [30, 40, 50] # different initial speeds in m/s angle = 45 # fixed launch angle in degrees theta = np.radians(angle) g = 9.81 # gravity in m/s^2 # Create the plot plt.figure(figsize=(10, 6)) for v0 in speeds: t_flight = 2 * v0 * np.sin(theta) / g # total flight time t = np.linspace(0, t_flight, num=500) # time points x = v0 * np.cos(theta) * t # horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # vertical position plt.plot(x, y, label=f'{v0} m/s') # Customize the plot plt.title('Projectile Motion at 45\u00b0 with Different Speeds') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations","text":"Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch velocity. We assume a 2D plane, neglecting air resistance for simplicity. The fundamental equations arise from Newton\u2019s second law, where the only force is gravity acting downward. The acceleration is: x-direction : \\(a_x = 0\\) y-direction : \\(a_y = -g\\) , where \\(g = 9.81 \\, \\text{m/s}^2\\) . Integrating acceleration with respect to time: Velocity : \\(v_x(t) = v_0 \\cos \\theta\\) \\(v_y(t) = v_0 \\sin \\theta - g t\\) Position : \\(x(t) = (v_0 \\cos \\theta) t\\) \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2\\) Here, \\(v_0\\) is the initial velocity, and \\(\\theta\\) is the angle of projection relative to the horizontal. These equations assume launch from the origin ( \\(x_0 = 0, y_0 = 0\\) ).","title":"Derivation of Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The equations form a parametric family of solutions, with free parameters: - Initial velocity ( \\(v_0\\) ): Scales the trajectory size. - Angle of projection ( \\(\\theta\\) ): Determines the shape of the parabolic path. - Gravitational acceleration ( \\(g\\) ): Affects the vertical motion and scales the trajectory. Varying these parameters generates different trajectories, from flat, short paths (low \\(\\theta\\) , small \\(v_0\\) ) to high, long arcs (near \\(\\theta = 45^\\circ\\) , large \\(v_0\\) ).","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-derivation","text":"The range is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : \\((v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = 0\\) Factor out \\(t\\) : \\(t \\left( v_0 \\sin \\theta - \\frac{1}{2} g t \\right) = 0\\) Solutions are \\(t = 0\\) (launch) and: \\(t = \\frac{2 v_0 \\sin \\theta}{g}\\) Substitute into \\(x(t)\\) : \\(R = x\\left( \\frac{2 v_0 \\sin \\theta}{g} \\right) = (v_0 \\cos \\theta) \\cdot \\frac{2 v_0 \\sin \\theta}{g} = \\frac{2 v_0^2 \\sin \\theta \\cos \\theta}{g}\\) Using the identity \\(\\sin 2\\theta = 2 \\sin \\theta \\cos \\theta\\) : \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) This shows the range depends on \\(\\theta\\) , \\(v_0\\) , and \\(g\\) .","title":"Range Derivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dependence-on-angle-of-projection","text":"The term \\(\\sin 2\\theta\\) governs the angular dependence. Since \\(\\sin 2\\theta\\) peaks at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) , the maximum range occurs at: \\(R_{\\text{max}} = \\frac{v_0^2}{g} \\quad (\\text{when } \\sin 2\\theta = 1)\\) For \\(\\theta < 45^\\circ\\) or \\(\\theta > 45^\\circ\\) , the range decreases symmetrically, as \\(\\sin 2(90^\\circ - \\theta) = \\sin 2\\theta\\) . Thus, angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges.","title":"Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-other-parameters","text":"Initial Velocity ( \\(v_0\\) ) : The range scales with \\(v_0^2\\) , so doubling \\(v_0\\) quadruples the range. Gravitational Acceleration ( \\(g\\) ) : The range is inversely proportional to \\(g\\) . On a planet with lower \\(g\\) , the range increases. Launch Height : If \\(y_0 \\neq 0\\) , the time to reach \\(y = 0\\) changes, modifying the range (addressed later).","title":"Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"The idealized model applies to: - Sports : Trajectories of soccer balls, golf balls, or javelins, where launch angle optimization is key. - Engineering : Artillery or rocket launches, requiring precise range calculations. - Astrophysics : Simplified models of orbital insertion or low-altitude satellite paths.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#extensions-to-real-world-scenarios","text":"Uneven Terrain : If the landing height differs from the launch height, solve \\(y(t) = y_{\\text{land}}\\) . For a height difference \\(h\\) : \\(y(t) = (v_0 \\sin \\theta) t - \\frac{1}{2} g t^2 = h\\) This yields a quadratic equation for \\(t\\) , and the range becomes: \\(R = (v_0 \\cos \\theta) t_{\\text{land}}\\) Air Resistance : Introduce a drag force proportional to velocity or its square, modifying the differential equations to: \\(m \\ddot{x} = -k \\dot{x}, \\quad m \\ddot{y} = -m g - k \\dot{y}\\) These require numerical solutions, as analytical forms are complex.","title":"Extensions to Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate projectile motion and visualize the range as a function of \\(\\theta\\) . import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # m/s^2 v0_values = [10, 20, 30] # Initial velocities (m/s) theta_deg = np.arange(0, 91, 1) # Angles from 0 to 90 degrees theta_rad = np.deg2rad(theta_deg) # Range function def range_projectile(v0, theta_rad, g=9.81): return (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs angle for different v0 plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_projectile(v0, theta_rad) plt.plot(theta_deg, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Simulate a single trajectory (example: v0 = 20 m/s, theta = 45 deg) v0 = 20 theta = np.deg2rad(45) t_flight = (2 * v0 * np.sin(theta)) / g t = np.linspace(0, t_flight, 100) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 plt.figure(figsize=(10, 6)) plt.plot(x, y) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Projectile Trajectory (v0 = 20 m/s, \u03b8 = 45\u00b0)') plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output-description","text":"Range Plot : Shows range vs. angle for \\(v_0 = 10, 20, 30 \\, \\text{m/s}\\) . Each curve peaks at \\(\\theta = 45^\\circ\\) , with higher \\(v_0\\) yielding larger ranges. Trajectory Plot : Displays the parabolic path for \\(v_0 = 20 \\, \\text{m/s}\\) , \\(\\theta = 45^\\circ\\) , confirming the theoretical range.","title":"Output Description"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations","text":"Idealized Model : Assumes no air resistance, constant gravity, and flat terrain. Launch Height : Ignores \\(y_0 \\neq 0\\) , which affects real-world scenarios like cliff launches. Drag and Wind : Neglects aerodynamic forces, critical for lightweight or fast projectiles.","title":"Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#suggestions-for-realism","text":"Air Resistance : Solve the modified differential equations numerically using tools like scipy.integrate.odeint . Wind : Add a velocity-dependent force term to model crosswinds. Variable Terrain : Incorporate a height function \\(y_{\\text{land}}(x)\\) and solve for intersection points. Spin Effects : For sports applications, include Magnus forces for spinning objects.","title":"Suggestions for Realism"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis reveals the elegance of projectile motion, with the range\u2019s dependence on \\(\\sin 2\\theta\\) highlighting the optimal \\(45^\\circ\\) angle. Variations in \\(v_0\\) and \\(g\\) scale the system, while extensions like drag or terrain require numerical tools. The model\u2019s simplicity belies its power to describe diverse phenomena, from sports to space exploration. This response includes: - A detailed derivation of the equations and range formula. - Analysis of parameter effects. - Python code for simulations and visualizations. - Discussion of real-world applications and model limitations. Let me know if you\u2019d like further refinements or additional scenarios (e.g., air resistance simulation)! import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 # initial velocity in m/s angles = [15, 45, 75] # launch angles in degrees g = 9.81 # acceleration due to gravity in m/s^2 # Create the plot plt.figure(figsize=(10, 6)) for angle in angles: theta = np.radians(angle) # convert degrees to radians t_flight = 2 * v0 * np.sin(theta) / g # total time of flight t = np.linspace(0, t_flight, num=500) # time points x = v0 * np.cos(theta) * t # horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # vertical position plt.plot(x, y, label=f'{angle}\u00b0') # Customize the plot plt.title('Projectile Motion at 50 m/s with Different Angles') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.show() P\u0131cture Code import numpy as np import matplotlib.pyplot as plt # Constants speeds = [30, 40, 50] # different initial speeds in m/s angle = 45 # fixed launch angle in degrees theta = np.radians(angle) g = 9.81 # gravity in m/s^2 # Create the plot plt.figure(figsize=(10, 6)) for v0 in speeds: t_flight = 2 * v0 * np.sin(theta) / g # total flight time t = np.linspace(0, t_flight, num=500) # time points x = v0 * np.cos(theta) * t # horizontal position y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # vertical position plt.plot(x, y, label=f'{v0} m/s') # Customize the plot plt.title('Projectile Motion at 45\u00b0 with Different Speeds') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.legend() plt.grid(True) plt.show()","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is governed by: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] where: \\(\\theta(t)\\) : Angular displacement (rad) \\(\\beta\\) : Damping coefficient (s\u207b\u00b9) \\(\\omega_0 = \\sqrt{g/l}\\) : Natural frequency (rad/s), \\(g = 9.81 , \\text{m/s}^2\\) , \\(l\\) : pendulum length (m) \\(A\\) : Driving amplitude (rad/s\u00b2) \\(\\omega\\) : Driving frequency (rad/s) \\(t\\) : Time (s) Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin(\\theta) \\approx \\theta\\) , simplifying to: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This linear ODE has a solution combining homogeneous ( \\(\\theta_h\\) ) and particular ( \\(\\theta_p\\) ) parts: Homogeneous solution (underdamped, \\(\\beta < \\omega_0\\) ): \\[ \\theta_h(t) = e^{-\\beta t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right), \\quad \\omega_d = \\sqrt{\\omega_0^2 - \\beta^2} \\] Particular solution: Assume \\(\\theta_p(t) = D_1 \\cos(\\omega t) + D_2 \\sin(\\omega t)\\) . Solving: \\[ D_1 = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}, \\quad D_2 = \\frac{2A\\beta\\omega}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2} \\] Steady-state amplitude: \\[ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}} \\] Resonance Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(D\\) . Damping ( \\(\\beta > 0\\) ) prevents infinite amplitude, shifting the peak slightly. This amplifies energy transfer, increasing oscillation amplitude. 2. Analysis of Dynamics Parameter Effects Damping ( \\(\\beta\\) ): High \\(\\beta\\) suppresses amplitude and chaos; low \\(\\beta\\) allows complex dynamics. Driving amplitude ( \\(A\\) ): Large \\(A\\) induces nonlinearity, potentially chaotic motion. Driving frequency ( \\(\\omega\\) ): Near \\(\\omega_0\\) , resonance; far from \\(\\omega_0\\) , quasiperiodic or chaotic motion. Transition to Chaos The nonlinear \\(\\sin(\\theta)\\) term drives transitions from periodic (synchronized with driving) to chaotic motion (sensitive to initial conditions). Phase portraits show loops (periodic) or tangled paths (chaotic). Poincar\u00e9 sections display few points (periodic) or scattered clouds (chaotic). 3. Practical Applications Energy harvesting: Oscillatory motion in piezoelectric devices generates electricity. Structural engineering: Models vibrations in bridges under periodic forces. Electronics: Driven RLC circuits, analogous to the pendulum, used in signal processing. Biomechanics: Describes gait or robotic motion under periodic forcing. 4. Implementation The Python script below simulates the pendulum using Runge-Kutta, visualizing time series, phase portraits, Poincar\u00e9 sections, resonance curve, and bifurcation diagram. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # m/s^2 l = 1.0 # pendulum length (m) omega0 = np.sqrt(g / l) # natural frequency beta_values = [0.05, 0.1, 0.5] # damping coefficients A = 1.5 # driving amplitude omega = 2.0 # driving frequency t_span = (0, 100) # time span dt = 0.01 # time step t_eval = np.arange(0, 100, dt) theta0, omega0_init = 0.1, 0.0 # initial conditions # Differential equation def pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -2 * beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Simulate for different beta values plt.figure(figsize=(10, 6)) for beta in beta_values: sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta, omega0, A, omega)) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {beta}') plt.xlabel('Time (s)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Time Series for Different Damping Coefficients') plt.legend() plt.grid(True) plt.savefig('time_series.png') plt.show() # Phase portrait (example: beta = 0.1) sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta_values[1], omega0, A, omega)) theta, omega_dot = sol.y[0], sol.y[1] plt.figure(figsize=(8, 6)) plt.plot(theta, omega_dot) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait (\u03b2 = 0.1)') plt.grid(True) plt.savefig('phase_portrait.png') plt.show() # Poincar\u00e9 section T = 2 * np.pi / omega poincare_times = np.arange(0, sol.t[-1], T) poincare_indices = np.searchsorted(sol.t, poincare_times) theta_poincare = theta[poincare_indices] omega_poincare = omega_dot[poincare_indices] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section (\u03b2 = 0.1)') plt.grid(True) plt.savefig('poincare_section.png') plt.show() # Resonance curve omega_range = np.linspace(0.5, 3.0, 100) amplitude = A / np.sqrt((omega0**2 - omega_range**2)**2 + (2 * beta_values[1] * omega_range)**2) plt.figure(figsize=(10, 6)) plt.plot(omega_range, amplitude) plt.axvline(omega0, color='r', linestyle='--', label=r'$\\omega_0$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel('Amplitude (rad)') plt.title('Resonance Curve (\u03b2 = 0.1)') plt.legend() plt.grid(True) plt.savefig('resonance_curve.png') plt.show() # Bifurcation diagram A_range = np.linspace(0.5, 2.5, 100) theta_bifurcation = [] t_span_bif = (0, 200) t_eval_bif = np.arange(100, 200, dt) for A in A_range: sol_bif = solve_ivp(pendulum, t_span_bif, [theta0, omega0_init], method='RK45', t_eval=t_eval_bif, args=(beta_values[1], omega0, A, omega)) theta_bif = sol_bif.y[0] poincare_indices_bif = np.searchsorted(sol_bif.t, np.arange(100, 200, T)) theta_bifurcation.extend(theta_bif[poincare_indices_bif]) A_bifurcation = np.repeat(A_range, len(poincare_indices_bif)) plt.figure(figsize=(10, 6)) plt.scatter(A_bifurcation, theta_bifurcation, s=1, alpha=0.5) plt.xlabel('Driving Amplitude $A$ (rad/s\u00b2)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Bifurcation Diagram (\u03b2 = 0.1)') plt.grid(True) plt.savefig('bifurcation_diagram.png') plt.show() Output Description Time Series: Shows \\(\\theta(t)\\) for \\(\\beta = 0.05, 0.1, 0.5\\) , illustrating damping effects. Phase Portrait: Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for \\(\\beta = 0.1\\) , showing trajectory behavior. Poincar\u00e9 Section: Displays states at driving periods for \\(\\beta = 0.1\\) , indicating periodic or chaotic motion. Resonance Curve: Plots amplitude vs. \\(\\omega\\) for \\(\\beta = 0.1\\) , peaking near \\(\\omega_0\\) . Bifurcation Diagram: Shows \\(\\theta\\) at Poincar\u00e9 times vs. \\(A\\) , revealing transitions to chaos. Limitations and Extensions Limitations Small-angle approximation fails for large \\(\\theta\\) . Linear damping oversimplifies real friction. Assumes periodic forcing, limiting real-world applicability. Extensions Model nonlinear damping (e.g., \\(|\\dot{\\theta}|\\dot{\\theta}\\) ). Include non-periodic or random forcing. Simulate coupled pendulums for complex interactions. Conclusion The forced damped pendulum, governed by \\(\\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t)\\) , exhibits rich dynamics from resonance to chaos. Simulations reveal parameter effects, with visualizations highlighting transitions. Applications span engineering and physics, and extensions could enhance realism. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) t_span = (0, 20) # time interval t_eval = np.linspace(*t_span, 1000) theta0 = np.radians(45) # initial angle (convert degrees to radians) omega0 = 0.0 # initial angular velocity # Equation of motion def pendulum(t, y, b, A, omega_f): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_f * t) return [dtheta_dt, domega_dt] # Scenario definitions scenarios = { \"Pure Pendulum (b=0, A=0)\": {\"b\": 0.0, \"A\": 0.0, \"omega_f\": 0.0}, \"Damped Pendulum (b=0.5, A=0)\": {\"b\": 0.5, \"A\": 0.0, \"omega_f\": 0.0}, \"Forced Pendulum (b=0, A=1)\": {\"b\": 0.0, \"A\": 1.0, \"omega_f\": 2.0}, } # Plotting fig, axes = plt.subplots(len(scenarios), 2, figsize=(12, 10)) fig.suptitle(\"Pendulum Dynamics\", fontsize=16) for i, (title, params) in enumerate(scenarios.items()): sol = solve_ivp(pendulum, t_span, [theta0, omega0], args=(params[\"b\"], params[\"A\"], params[\"omega_f\"]), t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] time = sol.t # Angle vs Time axes[i, 0].plot(time, theta) axes[i, 0].set_title(f\"{title} - Angle vs Time\") axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"Angle (rad)\") axes[i, 0].grid(True) # Phase Diagram (Angle vs Angular Velocity) axes[i, 1].plot(theta, omega) axes[i, 1].set_title(f\"{title} - Phase Diagram\") axes[i, 1].set_xlabel(\"Angle (rad)\") axes[i, 1].set_ylabel(\"Angular Velocity (rad/s)\") axes[i, 1].grid(True) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Governing Equation The motion of a forced damped pendulum is governed by: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t) \\] where: \\(\\theta(t)\\) : Angular displacement (rad) \\(\\beta\\) : Damping coefficient (s\u207b\u00b9) \\(\\omega_0 = \\sqrt{g/l}\\) : Natural frequency (rad/s), \\(g = 9.81 , \\text{m/s}^2\\) , \\(l\\) : pendulum length (m) \\(A\\) : Driving amplitude (rad/s\u00b2) \\(\\omega\\) : Driving frequency (rad/s) \\(t\\) : Time (s) Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin(\\theta) \\approx \\theta\\) , simplifying to: \\[ \\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\theta = A\\cos(\\omega t) \\] This linear ODE has a solution combining homogeneous ( \\(\\theta_h\\) ) and particular ( \\(\\theta_p\\) ) parts: Homogeneous solution (underdamped, \\(\\beta < \\omega_0\\) ): \\[ \\theta_h(t) = e^{-\\beta t} \\left( C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t) \\right), \\quad \\omega_d = \\sqrt{\\omega_0^2 - \\beta^2} \\] Particular solution: Assume \\(\\theta_p(t) = D_1 \\cos(\\omega t) + D_2 \\sin(\\omega t)\\) . Solving: \\[ D_1 = \\frac{A (\\omega_0^2 - \\omega^2)}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}, \\quad D_2 = \\frac{2A\\beta\\omega}{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2} \\] Steady-state amplitude: \\[ D = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta\\omega)^2}} \\] Resonance Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(D\\) . Damping ( \\(\\beta > 0\\) ) prevents infinite amplitude, shifting the peak slightly. This amplifies energy transfer, increasing oscillation amplitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Parameter Effects Damping ( \\(\\beta\\) ): High \\(\\beta\\) suppresses amplitude and chaos; low \\(\\beta\\) allows complex dynamics. Driving amplitude ( \\(A\\) ): Large \\(A\\) induces nonlinearity, potentially chaotic motion. Driving frequency ( \\(\\omega\\) ): Near \\(\\omega_0\\) , resonance; far from \\(\\omega_0\\) , quasiperiodic or chaotic motion. Transition to Chaos The nonlinear \\(\\sin(\\theta)\\) term drives transitions from periodic (synchronized with driving) to chaotic motion (sensitive to initial conditions). Phase portraits show loops (periodic) or tangled paths (chaotic). Poincar\u00e9 sections display few points (periodic) or scattered clouds (chaotic).","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting: Oscillatory motion in piezoelectric devices generates electricity. Structural engineering: Models vibrations in bridges under periodic forces. Electronics: Driven RLC circuits, analogous to the pendulum, used in signal processing. Biomechanics: Describes gait or robotic motion under periodic forcing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"The Python script below simulates the pendulum using Runge-Kutta, visualizing time series, phase portraits, Poincar\u00e9 sections, resonance curve, and bifurcation diagram. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # m/s^2 l = 1.0 # pendulum length (m) omega0 = np.sqrt(g / l) # natural frequency beta_values = [0.05, 0.1, 0.5] # damping coefficients A = 1.5 # driving amplitude omega = 2.0 # driving frequency t_span = (0, 100) # time span dt = 0.01 # time step t_eval = np.arange(0, 100, dt) theta0, omega0_init = 0.1, 0.0 # initial conditions # Differential equation def pendulum(t, y, beta, omega0, A, omega): theta, omega_dot = y return [omega_dot, -2 * beta * omega_dot - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] # Simulate for different beta values plt.figure(figsize=(10, 6)) for beta in beta_values: sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta, omega0, A, omega)) plt.plot(sol.t, sol.y[0], label=f'\u03b2 = {beta}') plt.xlabel('Time (s)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Time Series for Different Damping Coefficients') plt.legend() plt.grid(True) plt.savefig('time_series.png') plt.show() # Phase portrait (example: beta = 0.1) sol = solve_ivp(pendulum, t_span, [theta0, omega0_init], method='RK45', t_eval=t_eval, args=(beta_values[1], omega0, A, omega)) theta, omega_dot = sol.y[0], sol.y[1] plt.figure(figsize=(8, 6)) plt.plot(theta, omega_dot) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Phase Portrait (\u03b2 = 0.1)') plt.grid(True) plt.savefig('phase_portrait.png') plt.show() # Poincar\u00e9 section T = 2 * np.pi / omega poincare_times = np.arange(0, sol.t[-1], T) poincare_indices = np.searchsorted(sol.t, poincare_times) theta_poincare = theta[poincare_indices] omega_poincare = omega_dot[poincare_indices] plt.figure(figsize=(8, 6)) plt.scatter(theta_poincare, omega_poincare, s=10) plt.xlabel(r'$\\theta$ (rad)') plt.ylabel(r'$\\dot{\\theta}$ (rad/s)') plt.title('Poincar\u00e9 Section (\u03b2 = 0.1)') plt.grid(True) plt.savefig('poincare_section.png') plt.show() # Resonance curve omega_range = np.linspace(0.5, 3.0, 100) amplitude = A / np.sqrt((omega0**2 - omega_range**2)**2 + (2 * beta_values[1] * omega_range)**2) plt.figure(figsize=(10, 6)) plt.plot(omega_range, amplitude) plt.axvline(omega0, color='r', linestyle='--', label=r'$\\omega_0$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel('Amplitude (rad)') plt.title('Resonance Curve (\u03b2 = 0.1)') plt.legend() plt.grid(True) plt.savefig('resonance_curve.png') plt.show() # Bifurcation diagram A_range = np.linspace(0.5, 2.5, 100) theta_bifurcation = [] t_span_bif = (0, 200) t_eval_bif = np.arange(100, 200, dt) for A in A_range: sol_bif = solve_ivp(pendulum, t_span_bif, [theta0, omega0_init], method='RK45', t_eval=t_eval_bif, args=(beta_values[1], omega0, A, omega)) theta_bif = sol_bif.y[0] poincare_indices_bif = np.searchsorted(sol_bif.t, np.arange(100, 200, T)) theta_bifurcation.extend(theta_bif[poincare_indices_bif]) A_bifurcation = np.repeat(A_range, len(poincare_indices_bif)) plt.figure(figsize=(10, 6)) plt.scatter(A_bifurcation, theta_bifurcation, s=1, alpha=0.5) plt.xlabel('Driving Amplitude $A$ (rad/s\u00b2)') plt.ylabel(r'$\\theta$ (rad)') plt.title('Bifurcation Diagram (\u03b2 = 0.1)') plt.grid(True) plt.savefig('bifurcation_diagram.png') plt.show() Output Description Time Series: Shows \\(\\theta(t)\\) for \\(\\beta = 0.05, 0.1, 0.5\\) , illustrating damping effects. Phase Portrait: Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) for \\(\\beta = 0.1\\) , showing trajectory behavior. Poincar\u00e9 Section: Displays states at driving periods for \\(\\beta = 0.1\\) , indicating periodic or chaotic motion. Resonance Curve: Plots amplitude vs. \\(\\omega\\) for \\(\\beta = 0.1\\) , peaking near \\(\\omega_0\\) . Bifurcation Diagram: Shows \\(\\theta\\) at Poincar\u00e9 times vs. \\(A\\) , revealing transitions to chaos. Limitations and Extensions Limitations Small-angle approximation fails for large \\(\\theta\\) . Linear damping oversimplifies real friction. Assumes periodic forcing, limiting real-world applicability. Extensions Model nonlinear damping (e.g., \\(|\\dot{\\theta}|\\dot{\\theta}\\) ). Include non-periodic or random forcing. Simulate coupled pendulums for complex interactions. Conclusion The forced damped pendulum, governed by \\(\\ddot{\\theta} + 2\\beta\\dot{\\theta} + \\omega_0^2\\sin(\\theta) = A\\cos(\\omega t)\\) , exhibits rich dynamics from resonance to chaos. Simulations reveal parameter effects, with visualizations highlighting transitions. Applications span engineering and physics, and extensions could enhance realism. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # pendulum length (m) t_span = (0, 20) # time interval t_eval = np.linspace(*t_span, 1000) theta0 = np.radians(45) # initial angle (convert degrees to radians) omega0 = 0.0 # initial angular velocity # Equation of motion def pendulum(t, y, b, A, omega_f): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(omega_f * t) return [dtheta_dt, domega_dt] # Scenario definitions scenarios = { \"Pure Pendulum (b=0, A=0)\": {\"b\": 0.0, \"A\": 0.0, \"omega_f\": 0.0}, \"Damped Pendulum (b=0.5, A=0)\": {\"b\": 0.5, \"A\": 0.0, \"omega_f\": 0.0}, \"Forced Pendulum (b=0, A=1)\": {\"b\": 0.0, \"A\": 1.0, \"omega_f\": 2.0}, } # Plotting fig, axes = plt.subplots(len(scenarios), 2, figsize=(12, 10)) fig.suptitle(\"Pendulum Dynamics\", fontsize=16) for i, (title, params) in enumerate(scenarios.items()): sol = solve_ivp(pendulum, t_span, [theta0, omega0], args=(params[\"b\"], params[\"A\"], params[\"omega_f\"]), t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] time = sol.t # Angle vs Time axes[i, 0].plot(time, theta) axes[i, 0].set_title(f\"{title} - Angle vs Time\") axes[i, 0].set_xlabel(\"Time (s)\") axes[i, 0].set_ylabel(\"Angle (rad)\") axes[i, 0].grid(True) # Phase Diagram (Angle vs Angular Velocity) axes[i, 1].plot(theta, omega) axes[i, 1].set_title(f\"{title} - Phase Diagram\") axes[i, 1].set_xlabel(\"Angle (rad)\") axes[i, 1].set_ylabel(\"Angular Velocity (rad/s)\") axes[i, 1].grid(True) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Great! Here's a structured outline and starting content for your Markdown document with Python code and explanations to address Problem 1: Orbital Period and Orbital Radius . Gravity: Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law reveals that the square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis (or radius for circular orbits) of its orbit. Mathematically: \\[ T^2 \\propto r^3 \\] This relationship bridges the laws of motion and gravitation and allows us to calculate orbital parameters for celestial bodies, aiding everything from GPS satellite operations to interplanetary missions. Derivation of the Relationship Consider a small mass \\(m\\) orbiting a large mass \\(M\\) in a circular orbit of radius \\(r\\) . The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and solve for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] Implications in Astronomy Calculate planetary masses: Rearranging the law gives \\(M = \\frac{4\\pi^2 r^3}{G T^2}\\) , allowing us to estimate a star's or planet\u2019s mass. Estimate distances in space: If you know the period, you can deduce the orbital radius\u2014and vice versa. Apply to moons, satellites, and exoplanets: Kepler\u2019s Law holds for any object under central gravitational force. \ud83c\udf0d Real-World Examples 1. The Moon orbiting Earth \\(r \\approx 3.84 \\times 10^8\\) m \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) seconds Using \\(T^2 = \\frac{4\\pi^2 r^3}{GM}\\) , this checks out with the known mass of Earth \\((5.97 \\times 10^{24} \\text{kg})\\) . 2. Planets in the Solar System Plotting \\(\\log(T^2)\\) vs \\(\\log(r^3)\\) gives a straight line\u2014evidence of Kepler\u2019s Law. Computational Simulation (Python) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (mass of the Sun) # Orbital radii from 0.1 AU to 30 AU radii = np.linspace(0.1, 30, 100) * 1.496e11 # in meters # Calculate orbital periods using Kepler's third law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Convert radius to AU and period to years for easier interpretation radii_AU = radii / 1.496e11 T_years = T / (60 * 60 * 24 * 365.25) # Plot plt.figure(figsize=(8,6)) plt.loglog(radii_AU, T_years, label='Kepler\u2019s Third Law') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (years)') plt.title('Orbital Period vs Orbital Radius') plt.grid(True, which='both') plt.legend() plt.show() Elliptical Orbits and Generalization For elliptical orbits, Kepler's Third Law still holds using the semi-major axis \\(a\\) instead of the radius: \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] This insight extends to: Binary star systems Exoplanets Artificial satellites Summary The square of the orbital period is proportional to the cube of the orbital radius: \\(T^2 \\propto r^3\\) This relationship is derived from Newton's law of gravitation and centripetal force It enables mass and distance calculations across astronomy The simulation confirms the law numerically and visually import matplotlib.pyplot as plt import numpy as np # Planetary data planets = { 'Mercury': {'T': 87.97 * 24 * 3600, 'r': 57.91e9}, 'Venus': {'T': 224.7 * 24 * 3600, 'r': 108.21e9}, 'Earth': {'T': 365.25 * 24 * 3600, 'r': 149.60e9}, 'Mars': {'T': 687 * 24 * 3600, 'r': 227.92e9} } # Prepare data T2 = [] r3 = [] labels = [] for planet, data in planets.items(): T = data['T'] r = data['r'] T2.append(T**2) r3.append(r**3) labels.append(planet) # Linear regression (fit a line: T\u00b2 = slope * r\u00b3 + intercept) slope, intercept = np.polyfit(r3, T2, 1) fit_line = np.poly1d([slope, intercept]) # Generate x-values for the fit line r3_fit = np.linspace(min(r3), max(r3), 500) T2_fit = fit_line(r3_fit) # Plot points and the fit line plt.figure(figsize=(8, 6)) plt.plot(r3, T2, 'o', color='blue', label='Planets') plt.plot(r3_fit, T2_fit, '-', color='red', label='Best Fit Line') for i, label in enumerate(labels): plt.annotate(label, (r3[i], T2[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: print slope to verify Kepler constant print(f\"Slope (T\u00b2/r\u00b3) \u2248 {slope:.3e} s\u00b2/m\u00b3\") import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T = [0.241, 0.615, 1.0, 1.881] # Orbital periods (years) r = [0.39, 0.72, 1.0, 1.52] # Distances from Sun (AU) # Calculate T^2 and r^3 T_squared = [t**2 for t in T] r_cubed = [radius**3 for radius in r] # Create the plot plt.figure(figsize=(8,6)) plt.scatter(r_cubed, T_squared, color='blue') # Annotate each point with the planet name for i in range(len(planets)): plt.text(r_cubed[i], T_squared[i], planets[i], fontsize=9, ha='right') plt.title(\"Kepler's Third Law Verification: $T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True) plt.axis('equal') # Equal scaling of axes plt.tight_layout() plt.show() import math Constants \\(G = 6.67430e-11\\) # Gravitational constant in \\(m^3 kg^-1 s^-2\\) pi = math.pi Function to calculate mass using Kepler's Third Law \\(def calculate_mass(T, r):\\) T in seconds, r in meters \\(T^2 = (4 \\ pi^2 / (G \\ M)) \\ r^3\\) \\(M = (4 \\ pi^2 \\ r^3) / (G \\ T^2)\\) return \\((4 \\ pi^2 \\ r^3) / (G \\ T^2)\\) Earth's mass using Moon's orbit \\(T_moon = 27.322 \\times 24 \\times 3600\\) # Moon's orbital period in seconds \\(r_moon = 384400 \\times 1000\\) # Moon's orbital radius in meters mass_earth = calculate_mass(T_moon, r_moon) Sun's mass using Earth's orbit $T_earth = 365.256 \\times 24 \\times 3600 $ # Earth's orbital period in seconds $r_earth = 149.6e6 \\times 1000 $ # Earth's orbital radius in meters mass_sun = calculate_mass(T_earth, r_earth) Mass of Earth: ~5.97e24 kg Mass of Sun: ~1.99e30 kg","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-orbital-period-and-orbital-radius","text":"","title":"Gravity: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law reveals that the square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis (or radius for circular orbits) of its orbit. Mathematically: \\[ T^2 \\propto r^3 \\] This relationship bridges the laws of motion and gravitation and allows us to calculate orbital parameters for celestial bodies, aiding everything from GPS satellite operations to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship","text":"Consider a small mass \\(m\\) orbiting a large mass \\(M\\) in a circular orbit of radius \\(r\\) . The gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and solve for orbital speed \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The period \\(T\\) is the time to complete one orbit: \\[ T = \\frac{2\\pi r}{v} = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Calculate planetary masses: Rearranging the law gives \\(M = \\frac{4\\pi^2 r^3}{G T^2}\\) , allowing us to estimate a star's or planet\u2019s mass. Estimate distances in space: If you know the period, you can deduce the orbital radius\u2014and vice versa. Apply to moons, satellites, and exoplanets: Kepler\u2019s Law holds for any object under central gravitational force.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"\ud83c\udf0d Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moon-orbiting-earth","text":"\\(r \\approx 3.84 \\times 10^8\\) m \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) seconds Using \\(T^2 = \\frac{4\\pi^2 r^3}{GM}\\) , this checks out with the known mass of Earth \\((5.97 \\times 10^{24} \\text{kg})\\) .","title":"1. The Moon orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"Plotting \\(\\log(T^2)\\) vs \\(\\log(r^3)\\) gives a straight line\u2014evidence of Kepler\u2019s Law.","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-simulation-python","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 1.989e30 # kg (mass of the Sun) # Orbital radii from 0.1 AU to 30 AU radii = np.linspace(0.1, 30, 100) * 1.496e11 # in meters # Calculate orbital periods using Kepler's third law T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Convert radius to AU and period to years for easier interpretation radii_AU = radii / 1.496e11 T_years = T / (60 * 60 * 24 * 365.25) # Plot plt.figure(figsize=(8,6)) plt.loglog(radii_AU, T_years, label='Kepler\u2019s Third Law') plt.xlabel('Orbital Radius (AU)') plt.ylabel('Orbital Period (years)') plt.title('Orbital Period vs Orbital Radius') plt.grid(True, which='both') plt.legend() plt.show()","title":"Computational Simulation (Python)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#elliptical-orbits-and-generalization","text":"For elliptical orbits, Kepler's Third Law still holds using the semi-major axis \\(a\\) instead of the radius: \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] This insight extends to: Binary star systems Exoplanets Artificial satellites","title":"Elliptical Orbits and Generalization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"The square of the orbital period is proportional to the cube of the orbital radius: \\(T^2 \\propto r^3\\) This relationship is derived from Newton's law of gravitation and centripetal force It enables mass and distance calculations across astronomy The simulation confirms the law numerically and visually import matplotlib.pyplot as plt import numpy as np # Planetary data planets = { 'Mercury': {'T': 87.97 * 24 * 3600, 'r': 57.91e9}, 'Venus': {'T': 224.7 * 24 * 3600, 'r': 108.21e9}, 'Earth': {'T': 365.25 * 24 * 3600, 'r': 149.60e9}, 'Mars': {'T': 687 * 24 * 3600, 'r': 227.92e9} } # Prepare data T2 = [] r3 = [] labels = [] for planet, data in planets.items(): T = data['T'] r = data['r'] T2.append(T**2) r3.append(r**3) labels.append(planet) # Linear regression (fit a line: T\u00b2 = slope * r\u00b3 + intercept) slope, intercept = np.polyfit(r3, T2, 1) fit_line = np.poly1d([slope, intercept]) # Generate x-values for the fit line r3_fit = np.linspace(min(r3), max(r3), 500) T2_fit = fit_line(r3_fit) # Plot points and the fit line plt.figure(figsize=(8, 6)) plt.plot(r3, T2, 'o', color='blue', label='Planets') plt.plot(r3_fit, T2_fit, '-', color='red', label='Best Fit Line') for i, label in enumerate(labels): plt.annotate(label, (r3[i], T2[i]), textcoords=\"offset points\", xytext=(0,10), ha='center') plt.xlabel('r\u00b3 (m\u00b3)') plt.ylabel('T\u00b2 (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 vs r\u00b3\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # Optional: print slope to verify Kepler constant print(f\"Slope (T\u00b2/r\u00b3) \u2248 {slope:.3e} s\u00b2/m\u00b3\") import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T = [0.241, 0.615, 1.0, 1.881] # Orbital periods (years) r = [0.39, 0.72, 1.0, 1.52] # Distances from Sun (AU) # Calculate T^2 and r^3 T_squared = [t**2 for t in T] r_cubed = [radius**3 for radius in r] # Create the plot plt.figure(figsize=(8,6)) plt.scatter(r_cubed, T_squared, color='blue') # Annotate each point with the planet name for i in range(len(planets)): plt.text(r_cubed[i], T_squared[i], planets[i], fontsize=9, ha='right') plt.title(\"Kepler's Third Law Verification: $T^2$ vs $r^3$\") plt.xlabel(\"$r^3$ (AU\u00b3)\") plt.ylabel(\"$T^2$ (years\u00b2)\") plt.grid(True) plt.axis('equal') # Equal scaling of axes plt.tight_layout() plt.show() import math","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"\\(G = 6.67430e-11\\) # Gravitational constant in \\(m^3 kg^-1 s^-2\\) pi = math.pi","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#function-to-calculate-mass-using-keplers-third-law","text":"\\(def calculate_mass(T, r):\\) T in seconds, r in meters \\(T^2 = (4 \\ pi^2 / (G \\ M)) \\ r^3\\) \\(M = (4 \\ pi^2 \\ r^3) / (G \\ T^2)\\) return \\((4 \\ pi^2 \\ r^3) / (G \\ T^2)\\)","title":"Function to calculate mass using Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#earths-mass-using-moons-orbit","text":"\\(T_moon = 27.322 \\times 24 \\times 3600\\) # Moon's orbital period in seconds \\(r_moon = 384400 \\times 1000\\) # Moon's orbital radius in meters mass_earth = calculate_mass(T_moon, r_moon)","title":"Earth's mass using Moon's orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#suns-mass-using-earths-orbit","text":"$T_earth = 365.256 \\times 24 \\times 3600 $ # Earth's orbital period in seconds $r_earth = 149.6e6 \\times 1000 $ # Earth's orbital radius in meters mass_sun = calculate_mass(T_earth, r_earth) Mass of Earth: ~5.97e24 kg Mass of Sun: ~1.99e30 kg","title":"Sun's mass using Earth's orbit"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (v\u2081): The minimum speed required for an object to achieve a stable circular orbit around a celestial body, also known as orbital velocity. It balances the gravitational pull with the centripetal force needed for circular motion. Second Cosmic Velocity (v\u2082): The escape velocity, the minimum speed needed for an object to escape the gravitational influence of a celestial body without further propulsion. At this speed, the object's kinetic energy equals the gravitational potential energy at the surface. Third Cosmic Velocity (v\u2083): The velocity required for an object to escape the gravitational influence of a star system (e.g., the Solar System) and enter interstellar space. It accounts for escaping both the planet's and the star's gravitational fields. Mathematical Derivations First Cosmic Velocity (v\u2081) For a circular orbit, the gravitational force provides the centripetal force:F_g = \\frac{G M m}{r^2} = \\frac{m v_1^2}{r \\(Solving for ( v_1 ):v_1 = \\sqrt\\) frac{G M}{r}$Where: ( G ): Gravitational constant (( 6.67430 \\times 10^{-11} , \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} )) ( M ): Mass of the celestial body (kg) ( r ): Radius of the orbit (typically the body's radius for surface-launched orbits, in meters) Second Cosmic Velocity (v\u2082) The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy: \\(frac{1}{2} m v_2^2 = \\frac{G M m}{r\\) Solving for ( v_2 ):v_2 = \\sqrt \\(frac{2 G M}{r}\\) Note that ( v_2 = \\sqrt{2} \\cdot v_1 ), meaning the escape velocity is ( \\sqrt{2} ) times the orbital velocity. Third Cosmic Velocity (v\u2083) The third cosmic velocity is the speed needed to escape the star's gravitational field from the planet's orbit. It is derived by considering the escape velocity from the star (e.g., the Sun) at the planet's orbital distance, combined with the planet's escape velocity. The simplified formula for a planet at distance ( R ) from the star (mass ( M_s )) is:v_3 \\approx \\sqrt{v_2^2 + v_ \\(text{esc,sun}}^2\\) Where v_ \\(text{esc,sun}} = \\sqrt\\) frac{2 G M_s}{R}} , and ( R ) is the distance from the star (e.g., Earth's distance from the Sun, ~1 AU). Parameters Affecting Velocities Mass of the Celestial Body (M): Higher mass increases gravitational pull, increasing all cosmic velocities. Radius of the Body (r): Larger radius reduces the velocity required, as the object is farther from the center of gravity. Distance from the Star (R): For ( v_3 ), the planet's distance from the star affects the escape velocity from the star's gravitational field. Python Implementation and Visualization The following Python script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter, and visualizes the results using Matplotlib. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2)M_sun = 1.989e30 # Mass of the Sun (kg)AU = 1.496e11 # Astronomical unit (m) Celestial body data: [Mass (kg), Radius (m), Distance from Sun (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.0 * AU], 'Mars': [6.417e23, 3.390e6, 1.524 * AU], 'Jupiter': [1.898e27, 6.991e7, 5.204 * AU]} Calculate velocities v1 = {} # First cosmic velocity (orbital)v2 = {} # Second cosmic velocity (escape)v3 = {} # Third cosmic velocity (interstellar) for body, (mass, radius, dist_sun) in bodies.items(): # First cosmic velocity v1[body] = np.sqrt(G * mass / radius) / 1000 # Convert to km/s # Second cosmic velocity v2[body] = np.sqrt(2 * G * mass / radius) / 1000 # Convert to km/s # Third cosmic velocity (approximation) v_esc_sun = np.sqrt(2 * G * M_sun / dist_sun) # Escape velocity from Sun v3[body] = np.sqrt(v2[body] 2 + (v_esc_sun / 1000) 2) # Combine, in km/s Visualization bodies_list = list(bodies.keys())v1_values = [v1[body] for body in bodies_list]v2_values = [v2[body] for body in bodies_list]v3_values = [v3[body] for body in bodies_list] x = np.arange(len(bodies_list))width = 0.25 plt.figure(figsize=(10, 6))plt.bar(x - width, v1_values, width, label='First Cosmic Velocity (v\u2081)', color='blue')plt.bar(x, v2_values, width, label='Second Cosmic Velocity (v\u2082)', color='orange')plt.bar(x + width, v3_values, width, label='Third Cosmic Velocity (v\u2083)', color='green') plt.xlabel('Celestial Body')plt.ylabel('Velocity (km/s)')plt.title('Cosmic Velocities for Earth, Mars, and Jupiter')plt.xticks(x, bodies_list)plt.legend()plt.grid(True, axis='y')plt.savefig('cosmic_velocities.png')","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities Definitions and Physical Meaning First Cosmic Velocity (v\u2081): The minimum speed required for an object to achieve a stable circular orbit around a celestial body, also known as orbital velocity. It balances the gravitational pull with the centripetal force needed for circular motion. Second Cosmic Velocity (v\u2082): The escape velocity, the minimum speed needed for an object to escape the gravitational influence of a celestial body without further propulsion. At this speed, the object's kinetic energy equals the gravitational potential energy at the surface. Third Cosmic Velocity (v\u2083): The velocity required for an object to escape the gravitational influence of a star system (e.g., the Solar System) and enter interstellar space. It accounts for escaping both the planet's and the star's gravitational fields. Mathematical Derivations First Cosmic Velocity (v\u2081) For a circular orbit, the gravitational force provides the centripetal force:F_g = \\frac{G M m}{r^2} = \\frac{m v_1^2}{r \\(Solving for ( v_1 ):v_1 = \\sqrt\\) frac{G M}{r}$Where: ( G ): Gravitational constant (( 6.67430 \\times 10^{-11} , \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} )) ( M ): Mass of the celestial body (kg) ( r ): Radius of the orbit (typically the body's radius for surface-launched orbits, in meters) Second Cosmic Velocity (v\u2082) The escape velocity is derived from energy conservation, where the kinetic energy equals the gravitational potential energy: \\(frac{1}{2} m v_2^2 = \\frac{G M m}{r\\) Solving for ( v_2 ):v_2 = \\sqrt \\(frac{2 G M}{r}\\) Note that ( v_2 = \\sqrt{2} \\cdot v_1 ), meaning the escape velocity is ( \\sqrt{2} ) times the orbital velocity. Third Cosmic Velocity (v\u2083) The third cosmic velocity is the speed needed to escape the star's gravitational field from the planet's orbit. It is derived by considering the escape velocity from the star (e.g., the Sun) at the planet's orbital distance, combined with the planet's escape velocity. The simplified formula for a planet at distance ( R ) from the star (mass ( M_s )) is:v_3 \\approx \\sqrt{v_2^2 + v_ \\(text{esc,sun}}^2\\) Where v_ \\(text{esc,sun}} = \\sqrt\\) frac{2 G M_s}{R}} , and ( R ) is the distance from the star (e.g., Earth's distance from the Sun, ~1 AU). Parameters Affecting Velocities Mass of the Celestial Body (M): Higher mass increases gravitational pull, increasing all cosmic velocities. Radius of the Body (r): Larger radius reduces the velocity required, as the object is farther from the center of gravity. Distance from the Star (R): For ( v_3 ), the planet's distance from the star affects the escape velocity from the star's gravitational field. Python Implementation and Visualization The following Python script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter, and visualizes the results using Matplotlib. import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2)M_sun = 1.989e30 # Mass of the Sun (kg)AU = 1.496e11 # Astronomical unit (m) Celestial body data: [Mass (kg), Radius (m), Distance from Sun (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.0 * AU], 'Mars': [6.417e23, 3.390e6, 1.524 * AU], 'Jupiter': [1.898e27, 6.991e7, 5.204 * AU]} Calculate velocities v1 = {} # First cosmic velocity (orbital)v2 = {} # Second cosmic velocity (escape)v3 = {} # Third cosmic velocity (interstellar) for body, (mass, radius, dist_sun) in bodies.items(): # First cosmic velocity v1[body] = np.sqrt(G * mass / radius) / 1000 # Convert to km/s # Second cosmic velocity v2[body] = np.sqrt(2 * G * mass / radius) / 1000 # Convert to km/s # Third cosmic velocity (approximation) v_esc_sun = np.sqrt(2 * G * M_sun / dist_sun) # Escape velocity from Sun v3[body] = np.sqrt(v2[body] 2 + (v_esc_sun / 1000) 2) # Combine, in km/s Visualization bodies_list = list(bodies.keys())v1_values = [v1[body] for body in bodies_list]v2_values = [v2[body] for body in bodies_list]v3_values = [v3[body] for body in bodies_list] x = np.arange(len(bodies_list))width = 0.25 plt.figure(figsize=(10, 6))plt.bar(x - width, v1_values, width, label='First Cosmic Velocity (v\u2081)', color='blue')plt.bar(x, v2_values, width, label='Second Cosmic Velocity (v\u2082)', color='orange')plt.bar(x + width, v3_values, width, label='Third Cosmic Velocity (v\u2083)', color='green') plt.xlabel('Celestial Body')plt.ylabel('Velocity (km/s)')plt.title('Cosmic Velocities for Earth, Mars, and Jupiter')plt.xticks(x, bodies_list)plt.legend()plt.grid(True, axis='y')plt.savefig('cosmic_velocities.png')","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}